import 'dart:math' as math;
import 'package:flutter/material.dart';

import 'tiny_color.dart';

extension StringToColor on String {
  int _getColorFromHex(String hexColor) {
    if (hexColor == null) hexColor = Colors.white.hexString;

    hexColor = hexColor.toUpperCase().replaceAll("#", "");
    if (hexColor.length == 6) {
      hexColor = "FF" + hexColor;
    }
    return int.parse(hexColor, radix: 16);
  }

  Color get toColor => Color(_getColorFromHex(this));
}

extension ColorExtension on Color {
  /// Colors.red.tweenTo(Colors.blue) // ColorTween(begin: Colors.red, end: Colors.blue);
  /// ```
  ColorTween tweenTo(Color end) {
    return ColorTween(begin: this, end: end);
  }

  /// Make color lighter by so many [percents]
  Color lighter(int percents) {
    assert(percents >= 1 && percents <= 100);
    final int rgbPercent = (percents / 100 * 255).round();
    int red = this.red + rgbPercent,
        green = this.green + rgbPercent,
        blue = this.blue + rgbPercent;
    if (red > 255) {
      red = 255;
    }
    if (green > 255) {
      green = 255;
    }
    if (blue > 255) {
      blue = 255;
    }
    return Color.fromARGB(alpha, red, green, blue);
  }

  /// Make color darker by so many [percents]
  Color darker(int percents) {
    assert(percents >= 1 && percents <= 100);
    final int rgbPercent = (percents / 100 * 255).round();
    int red = this.red - rgbPercent,
        green = this.green - rgbPercent,
        blue = this.blue - rgbPercent;
    if (red < 0) {
      red = 0;
    }
    if (green < 0) {
      green = 0;
    }
    if (blue < 0) {
      blue = 0;
    }
    return Color.fromARGB(alpha, red, green, blue);
  }

  /// Linearly interpolate between two colors.
  ///
  /// This is intended to be fast but as a result may be ugly. Consider
  /// HSVColor or writing custom logic for interpolating colors.
  ///
  /// If either color is null, this function linearly interpolates from a
  /// transparent instance of the other color. This is usually preferable to
  /// interpolating from [material.Colors.transparent] (`const
  /// Color(0x00000000)`), which is specifically transparent _black_.
  ///
  /// The `t` argument represents position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as Curves.elasticInOut). Each channel
  /// will be clamped to the range 0 to 255.
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an AnimationController.
  Color mix(Color another, double amount) => Color.lerp(this, another, amount);

  /// Convert color to hex string
  String get hexString => this == null
      ? Colors.blue.value
          .toRadixString(16)
          .substring(2, this.value.toRadixString(16).length)
      : this
          .value
          .toRadixString(16)
          .substring(2, this.value.toRadixString(16).length);

  lightenBy(int percent) => this.lighter(percent);

  darkenBy(int percent) => this.darker(percent);

  get _materialColor => generateSwatch(this);

  Color get shade50 => _materialColor[50];

  Color get shade100 => _materialColor[100];

  Color get shade200 => _materialColor[200];

  Color get shade300 => _materialColor[300];

  Color get shade400 => _materialColor[400];

  Color get shade500 => _materialColor[500];

  Color get shade600 => _materialColor[600];

  Color get shade700 => _materialColor[700];

  Color get shade800 => _materialColor[800];

  Color get shade900 => _materialColor[900];

  Color get compColor => CompColor(this.hexString);

  Color get textColor => TextColor(this);
}

class SmartColor {
  static Color parse(String color) => _getColor(color);

  static bool suitAntDesign(Color color) {
    HSLColor hslColor = HSLColor.fromColor(color);
    return hslColor.lightness * 100 >= 70 && hslColor.saturation * 100 >= 70;
  }

  static DesignColor antDColor(Color color) {
    Map<int, Color> colors = Map<int, Color>();
    for (int i = 1; i <= 10; i++) {
      colors[i] = SmartColor._makeAntDColor(color, i);
    }
    return DesignColor(color.value, colors);
  }

  static Color _makeAntDColor(Color color, int index) {
    bool isLight = index <= 6;
    HSVColor hsv = HSVColor.fromColor(color);
    int lightColorCount = 5;
    var i = isLight ? lightColorCount + 1 - index : index - lightColorCount - 1;
    return HSVColor.fromAHSV(
      1,
      _getHue(hsv, i, isLight),
      _getSaturation(hsv, i, isLight),
      _getValue(hsv, i, isLight),
    ).toColor();
  }

  static _getColor(String color) {
    Color rgbaColor = _getRGBAColorFromString(color);
    if (rgbaColor != null) {
      return rgbaColor;
    }
    return HexColor(color);
  }

  static Color _getRGBAColorFromString(String string) {
    string = string.replaceAll(" ", ""); // pseudo-trimming
    if (string.startsWith("rgba(") && string.endsWith(")")) {
      // Correct
      string = string.replaceAll("rgba(", "");
      string = string.replaceAll(")", "");
      List<String> rgba = string.split(",");
      if (rgba.length == 4) {
        int r = int.parse(rgba[0]);
        int g = int.parse(rgba[1]);
        int b = int.parse(rgba[2]);
        double a = double.parse(rgba[3]) * 255;
        return new Color.fromARGB(a.toInt(), r, g, b);
      }
      return null;
    }
    return null;
  }
}

class DesignColor extends ColorSwatch<int> {
  const DesignColor(int primary, Map<int, Color> swatch)
      : super(primary, swatch);

  Color get shade50 => this[1];

  Color get shade100 => this[2];

  Color get shade200 => this[3];

  Color get shade300 => this[4];

  Color get shade400 => this[5];

  Color get shade500 => this[6];

  Color get shade600 => this[7];

  Color get shade700 => this[8];

  Color get shade800 => this[9];

  Color get shade900 => this[10];
}

class HexColor extends Color {
  static int _getColorFromHex(String hexColor) {
    if (hexColor == null) hexColor = Colors.white.hexString;

    hexColor = hexColor.toUpperCase().replaceAll("#", "");
    if (hexColor.length == 6) {
      hexColor = "FF" + hexColor;
    }
    return int.parse(hexColor, radix: 16);
  }

  HexColor(final String hexColor) : super(_getColorFromHex(hexColor));
}

Color _textColor(Color color) {
  double amt = .29;
  double amt2 = .33;
  double lumin = color.computeLuminance();
  if (lumin > amt) {
    if (color == Colors.white) {
      return color.darkenBy(96);
    }
    if (lumin > amt2)
      return color.darkenBy(75);
    else
      return color.darkenBy(85);
  } else {
    return color.lightenBy(95);
  }
}

class TextColor extends Color {
  static double luminLevelOne = .29;
  static double luminLevelTwo = .33;

  static int _getBrandColorFromString(Color backgroundColor) {
    String shadedHex = _textColor(backgroundColor)
        .hexString
        .toUpperCase()
        .replaceAll("#",
            ""); // Color.fromARGB(255, d, d, d).hexString.toUpperCase().replaceAll("#", "");
    if (shadedHex.length == 6) {
      shadedHex = "FF" + shadedHex;
    }
    return int.parse(shadedHex, radix: 16);
  }

  TextColor(final Color backgroundColor)
      : super(_getBrandColorFromString(backgroundColor));
}

///getHue
double _getHue(HSVColor hsv, int i, bool isLight) {
  double hue;
  int hueStep = 2;
  if (hsv.hue >= 60 && hsv.hue <= 240) {
    hue = isLight == true ? hsv.hue - hueStep * i : hsv.hue + hueStep * i;
  } else {
    hue = isLight == true ? hsv.hue + hueStep * i : hsv.hue - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue.round().toDouble();
}

///getSaturation
double _getSaturation(HSVColor hsv, int i, bool isLight) {
  int saturation;
  int saturationStep = 16;
  int saturationStep2 = 5;
  int darkColorCount = 4;
  var lightColorCount = 5;
  if (isLight == true) {
    saturation = (hsv.saturation * 100).round() - saturationStep * i;
  } else if (i == darkColorCount) {
    saturation = (hsv.saturation * 100).round() + saturationStep;
  } else {
    saturation = (hsv.saturation * 100).round() + saturationStep2 * i;
  }
  if (saturation > 100) {
    saturation = 100;
  }
  if (isLight == true && i == lightColorCount && saturation > 10) {
    saturation = 10;
  }
  if (saturation < 6) {
    saturation = 6;
  }
  return saturation.toDouble() / 100;
}

/// getValue
double _getValue(HSVColor hsv, int i, bool isLight) {
  int brightnessStep1 = 5;
  int brightnessStep2 = 15;
  if (isLight == true) {
    return (((hsv.value * 100).round() + brightnessStep1 * i) > 100
                ? 100
                : ((hsv.value * 100).round() + brightnessStep1 * i))
            .toDouble() /
        100;
  }
  return ((hsv.value * 100).round() - brightnessStep2 * i).toDouble() / 100;
}

class CompColor extends Color {
  static int _hexToComplimentary(String colorString) {
    Color rgb = colorString.toColor;
    var r = (rgb.red / 255);
    var g = (rgb.green / 255);
    var b = (rgb.blue / 255);
    var mx = [r, g, b].reduce(math.max);
    var mn = [r, g, b].reduce(math.min);

    var h = (mx + mn) / 2.0;
    var s = (mx + mn) / 2.0;
    var l = (mx + mn) / 2.0;
    if (mx == mn) {
      h = s = 0; //achromatic
    } else {
      var d = mx - mn;
      s = (l > 0.5 ? d / (2.0 - mx - mn) : d / (mx + mn));

      if (mx == r && g >= b) {
        h = 1.0472 * (g - b) / d;
      } else if (mx == r && g < b) {
        h = 1.0472 * (g - b) / d + 6.2832;
      } else if (mx == g) {
        h = 1.0472 * (b - r) / d + 2.0944;
      } else if (mx == b) {
        h = 1.0472 * (r - g) / d + 4.1888;
      }
    }

    h = h / 6.2832 * 360.0 + 0;

    h += 180;
    if (h > 360) {
      h -= 360;
    }
    h /= 360;

    if (s == 0) {
      r = g = b = l; // achromatic
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    int R = (r * 255).round();
    int G = (g * 255).round();
    int B = (b * 255).round();

    Color compRGB = Color.fromARGB(255, R, G, B);

    String compHex = compRGB.hexString.toUpperCase().replaceAll("#", "");
    if (compHex.length == 6) {
      compHex = "FF" + compHex;
    }
    return int.parse(compHex, radix: 16);
  }

  static hue2rgb(var p, var q, var t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }

  CompColor(final String hexColor) : super(_hexToComplimentary(hexColor));
}

bool colorIsDark(Color color) {
  return TinyColor(color).isDark();
}

bool colorIsLight(Color color) {
  return TinyColor(color).isLight();
}

colorIsDarker(Color colorOne, Color colorTwo) {
  TinyColor(colorOne);
  ;
  return TinyColor(colorOne).getBrightness() <
      TinyColor(colorTwo).getBrightness();
}

colorIsBlack(Color color) {
  HexColor hex = HexColor(color.hexString);
  return hex.blue == 0 && hex.red == 0 && hex.green == 0;
}

MaterialColor generateSwatch(Color src) =>
    MaterialColor(src.value, _generateSwatch(src));

MaterialAccentColor generateAccent(Color src) =>
    MaterialAccentColor(src.value, _generateAccentSwatch(src));

Map<int, Color> _generateSwatch(Color base) {
  var darker = darken(base);
  var lighter = lighten(base);
  return {
    50: Color.fromARGB(255, base.red, base.green, base.blue).lighter(25),
    100: Color.fromARGB(255, base.red, base.green, base.blue).lighter(20),
    200: Color.fromARGB(255, base.red, base.green, base.blue).lighter(15),
    300: Color.fromARGB(255, base.red, base.green, base.blue).lighter(10),
    400: Color.fromARGB(255, base.red, base.green, base.blue).lighter(5),
    500: Color.fromARGB(255, base.red, base.green, base.blue),
    600: Color.fromARGB(255, base.red, base.green, base.blue).darker(5),
    700: Color.fromARGB(255, base.red, base.green, base.blue).darker(10),
    800: Color.fromARGB(255, base.red, base.green, base.blue).darker(15),
    900: Color.fromARGB(255, base.red, base.green, base.blue).darker(20),
  };
}

Map<int, Color> _generateAccentSwatch(Color hex) {
  var baseDark = darken(hex);
  var hslBase = HSLColor.fromColor(hex);
  var baseTriad = hslBase.withHue((hslBase.hue + 270) % 360).toColor();
  var accentBase = HSLColor.fromColor(Color.lerp(baseDark, baseTriad, 0.15));
  return {
    100: accentBase
        .withSaturation((accentBase.saturation + 0.80).clamp(0, 1))
        .withLightness((accentBase.lightness + 0.65).clamp(0, 1))
        .toColor(),
    200: accentBase
        .withSaturation((accentBase.saturation + 0.80).clamp(0, 1))
        .withLightness((accentBase.lightness + 0.55).clamp(0, 1))
        .toColor(),
    400: accentBase
        .withSaturation((accentBase.saturation + 1.00).clamp(0, 1))
        .withLightness((accentBase.lightness + 0.45).clamp(0, 1))
        .toColor(),
    700: accentBase
        .withSaturation((accentBase.saturation + 1.00).clamp(0, 1))
        .withLightness((accentBase.lightness + 0.40).clamp(0, 1))
        .toColor(),
  };
}

Color darken(Color c) => Color.fromARGB(-1, (c.red * c.red) ~/ 255,
    (c.green * c.green) ~/ 255, (c.blue * c.blue) ~/ 255);

Color lighten(Color c) => Color.fromARGB(
    -1,
    (math.sqrt(c.red / 255) * 255).floor(),
    (math.sqrt(c.green / 255) * 255).floor(),
    (math.sqrt(c.blue / 255) * 255).floor());

Color tweak(Color base, double bf, double df, double lf, double wf,
    {Color darker, Color lighter}) {
  if (darker == null) darker = darken(base);
  if (lighter == null) lighter = lighten(base);
  return Color.lerp(
      Colors.black,
      Color.lerp(Colors.white,
          Color.lerp(darker, Color.lerp(lighter, base, lf), df), wf),
      bf);
}

List<Color>	initColors(){
  List<Color> items = List();
  baseMaterialColors
      .forEach((element) => items.addAll(getMaterialColorShades(element)));
  accentMaterialColors.forEach((element) => items.addAll(getMaterialColorShades(element)));
  return items;
}

List<Color> get materialColors => initColors();


List<Color> getMaterialColorShades(ColorSwatch color) {
  return <Color>[
    if (color[50] != null) color[50],
    if (color[100] != null) color[100],
    if (color[200] != null) color[200],
    if (color[300] != null) color[300],
    if (color[400] != null) color[400],
    if (color[500] != null) color[500],
    if (color[600] != null) color[600],
    if (color[700] != null) color[700],
    if (color[800] != null) color[800],
    if (color[900] != null) color[900],
  ];
}

final List<ColorSwatch> baseMaterialColors = const <ColorSwatch>[
  Colors.red,
  Colors.pink,
  Colors.purple,
  Colors.deepPurple,
  Colors.indigo,
  Colors.blue,
  Colors.lightBlue,
  Colors.cyan,
  Colors.teal,
  Colors.green,
  Colors.lightGreen,
  Colors.lime,
  Colors.yellow,
  Colors.amber,
  Colors.orange,
  Colors.deepOrange,
  Colors.brown,
  Colors.grey,
  Colors.blueGrey,

];

final List<ColorSwatch> accentMaterialColors = const <ColorSwatch>[

  Colors.redAccent,
  Colors.pinkAccent,
  Colors.purpleAccent,
  Colors.deepPurpleAccent,
  Colors.indigoAccent,
  Colors.lightBlueAccent,
  Colors.blueAccent,
  Colors.cyanAccent,
  Colors.tealAccent,
  Colors.greenAccent,
  Colors.lightGreenAccent,
  Colors.limeAccent,
  Colors.yellowAccent,
  Colors.amberAccent,
  Colors.orangeAccent,
  Colors.deepOrangeAccent,
];


